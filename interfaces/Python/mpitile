#!/usr/bin/env python
from __future__ import print_function
import os
import sys
import argparse
from dipy import parallel, read_parameters_file, UNNAMED



def main():
    # mpitile supports SIMD and MIMD models. See the manpage for mpirun for a description.
    # To support MIMD, the command line arguments are split on colons (":"), and the
    # parser is invoked on each subset.
    
    # The first set of tokens must contain options to mpitile (e.g. --static).
    usage = "%(prog)s [tile options] [--] [global mpirun options] COMMAND1 : COMMAND2 : ..."
    parser = argparse.ArgumentParser(usage=usage,
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description="Run COMMAND(s) in parallel under SLURM+OpenMPI on an available tile.",
            epilog="%(prog)s is a wrapper for OpenMPI's MPI launcher mpirun. The mpirun\n" +
            "command must be on the PATH.\n\n" +
            "Options and arguments may be passed to mpirun (or the user's code) " +
            "by including\nthem in COMMANDs. If COMMAND contains any options that are " +
            "prefixed by a\ndash (\"-\"),then a double-dash must separate %(prog)s's " +
            "options and the COMMAND.\n\n" +
            "Example: Launch ./my_sim using 32 tasks, assuming a dedicated master. Pass\n" +
            "the option -verbose=OFF to ./my_sim and include --.\n\n" +
            "      %(prog)s -np 32 --dedicated-master -- ./my_sim -verbose=OFF")

    parser.add_argument("-n","-np","-c","--n",type=int, dest="applic_tasks",
            help="Number of MPI processes (tasks)", required=True)
    parser.add_argument("-m","--dedicated-master",action="store_true",dest="dedicated_master",
            default=False, help="Reserve the first node for Dakota")
    parser.add_argument("-V","--verbose",action="store_true", dest="verbose", default=False,
            help="Log status messages.")
    parser.add_argument("-u","--lock-id", dest="lock_id",
            help="Write lock files named <LOCK_ID>.<tile>. (Default: <SLURM_JOB_ID>.<tile>)")
    parser.add_argument("-l","--lock-dir",dest="lock_dir",
            help="Specify lock file directotry (Default: $HOME/.DakotaEvalTiling)")
    parser.add_argument("-s", "--static-scheduling",dest="static",action="store_true",
            default=False, 
            help="Use static scheduling instead of dynamic (no lock files). Use only in " +
            "concert with Dakota input keywords 'local_evaluation_scheduling static'")
    parser.add_argument("-e", "--eval-num", type=int, dest="eval_num",
            help="The evaluation number determines tile placement when using static " +
            "scheduling. (This option is ignored for the default, dynamic scheduling.)")
    parser.add_argument("-p", "--params-file", type=str, dest="params_file",
            help="Extract the evaluation number from the Dakota parameters file." + 
            "(This option is ignored for the default, dynamic scheduling, and when " +
            "--eval-num is given)")
    parser.add_argument("command",nargs="*", help=argparse.SUPPRESS)

    # Break up the command line arguments on ":"
    all_cl = sys.argv[1:]
    command_lines = []
    while True:
        try:
            cindex = all_cl.index(":")
            command_lines.append(all_cl[:cindex])
            del all_cl[:cindex+1]
        except ValueError:
            command_lines.append(all_cl[:])
            break

    # The first (and usually the only) set of tokens contains options to 
    # mpitile. Process these separately in order to extract them.
    tile_args = parser.parse_args(command_lines[0])
    # Commands is a list of tuples. Each tuple is (applic_tasks, command)
    commands = [(tile_args.applic_tasks, tile_args.command)]
    for line in command_lines[1:]:
        args = parser.parse_args(line)
        commands.append( (args.applic_tasks, args.command) )

    # Call tile_run_static or tile_run_dynamic to launch the user's code(s)
    if tile_args.static:
        if not tile_args.eval_num and not tile_args.params_file:
            print("An evaluation number (--eval-num) or Dakota parameters file (--params-file) " +
            "must be given when using --static.", file=sys.stderr)
            sys.exit(1)

        ret = parallel.tile_run_static(commands=commands,
                dedicated_master=tile_args.dedicated_master, eval_num=tile_args.eval_num, 
                parameters_file=tile_args.params_file)
    else:   
        ret = parallel.tile_run_dynamic(commands=commands,
                dedicated_master=tile_args.dedicated_master, lock_id=tile_args.lock_id, 
            lock_dir=tile_args.lock_dir)

    sys.exit(ret)

if __name__ == "__main__":
    main()




